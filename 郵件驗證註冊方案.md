# 郵件驗證註冊方案

## 一、現狀

- 註冊只需填寫：**電子郵件**、**密碼**、**再輸入一次密碼**。
- 點「建立帳號」後直接寫入 `users` 表並自動登入，無需驗證信箱是否為本人持有。
- 風險：可隨意用他人信箱註冊、假帳號、垃圾帳號。

---

## 二、目標

- 註冊時必須**驗證該信箱可收信**，確認為本人或可控信箱後才完成註冊。
- 不改變現有「帳號 + 密碼」登入方式；僅在**註冊流程**中增加驗證步驟。
- 可選：若管理員未設定發信，則保留「僅帳密註冊」或提示「驗證未啟用」。

---

## 三、驗證方式比較

| 方式 | 優點 | 缺點 |
|------|------|------|
| **驗證連結** | 點一次即完成，體驗好 | 需處理回調網址、token 過期、Streamlit 重跑後 state 易丟失 |
| **驗證碼（6 位數字）** | 實作簡單、不需回調網址、與 Streamlit 表單契合、易於除錯 | 用戶需多一步「收信並輸入」 |

**建議：採用「驗證碼（6 位數字）」**，在註冊頁輸入信箱與密碼後發送驗證碼，用戶在同一頁輸入驗證碼後完成註冊。

---

## 四、註冊流程（驗證碼方案）

1. **Step 1：填寫信箱與密碼**
   - 用戶輸入：電子郵件、密碼、再輸入一次密碼。
   - 點「發送驗證碼」：
     - 檢查格式、密碼強度、兩次密碼一致、該信箱未註冊。
     - 產生 6 位數驗證碼，寫入「待驗證」儲存（見下）。
     - 寄出郵件：「您的驗證碼是 XXXXXX，15 分鐘內有效。」
     - 畫面切換到 Step 2：顯示「已發送至 xxx@...，請輸入驗證碼」+ 驗證碼輸入框 + 「完成註冊」按鈕。

2. **Step 2：輸入驗證碼並完成註冊**
   - 用戶輸入驗證碼，點「完成註冊」：
     - 檢查驗證碼與暫存中的信箱、過期時間一致。
     - 將該筆待驗證資料寫入 `users`（等同現有註冊邏輯），並可標記為已驗證（若採用 `email_verified` 欄位）。
     - 清除該筆待驗證資料；可選：清除 session 中註冊用暫存。
     - 自動登入並導向主頁。

3. **未驗證前**
   - 不在 `users` 表建立正式帳號；僅在「待驗證」儲存中暫存：email、password_hash、驗證碼、過期時間。

4. **安全與體驗**
   - 驗證碼有效時間：建議 **15 分鐘**。
   - 同一信箱：建議 **每 3～5 分鐘僅可再發一次**，避免洗信。
   - 驗證碼：**6 位數字**，隨機產生，一次性使用。
   - 登入時：若未來在 `users` 加 `email_verified`，可僅允許 `email_verified = 1` 的帳號登入；舊用戶可視為已驗證（欄位 NULL 或 0 時依策略相容）。

---

## 五、資料儲存

### 5.1 待驗證註冊（pending verifications）

需暫存：**email**、**password_hash**、**verification_code**、**expires_at**。

- **方案 A：資料庫新表 `pending_verifications`**  
  - 欄位：id, email, password_hash, code, expires_at (或 created_at + 有效分鐘數)。  
  - 優點：重啟不丟失、多實例共用、可定期清理過期資料。  
  - 建議採用。

- **方案 B：僅用 session_state**  
  - 暫存於 `st.session_state`（例如 `pending_reg_email`, `pending_reg_password_hash`, `pending_reg_code`, `pending_reg_expires`）。  
  - 優點：無需改 DB。缺點：重新整理或逾時可能丟失，需重新發送驗證碼。

可先實作 **方案 A**，若希望極簡可再提供選項切換為 B（或僅在未設定 SMTP 時用 B 行為）。

### 5.2 正式用戶（users 表）

- 現有 `users` 表不刪欄位，僅**新增選用欄位**：`email_verified INTEGER DEFAULT 0`（0 未驗證，1 已驗證）。
- 註冊完成時寫入 `email_verified = 1`。
- 登入邏輯：若存在 `email_verified` 欄位，則僅允許 `email_verified = 1` 的帳號登入；**舊資料**：`email_verified` 為 NULL 時視為已驗證（相容既有用戶）。

---

## 六、發信方式（SMTP）

- 使用 Python 標準庫 **smtplib** 發送郵件即可，無需額外服務。
- 設定建議放在 **Streamlit Secrets**（或環境變數），例如：

```toml
# .streamlit/secrets.toml（僅範例，勿提交真實密碼）
SMTP_HOST = "smtp.gmail.com"
SMTP_PORT = "587"
SMTP_USER = "your-app@gmail.com"
SMTP_PASSWORD = "your-app-password"
MAIL_FROM = "您的服務名稱 <your-app@gmail.com>"
```

- 若使用 Gmail：需使用「應用程式密碼」，並開啟「低安全性應用程式」或依 Google 說明使用 OAuth。
- 其他常見 SMTP：Outlook、SendGrid、Mailgun、公司信箱等，只要支援 SMTP 即可。

### 未設定 SMTP 時

- **選項 1（建議）**：關閉郵件驗證，維持目前「僅帳密即可註冊」；畫面上可加一行說明：「未設定郵件驗證，註冊後即可登入。」
- **選項 2**：仍顯示「發送驗證碼」，但發送失敗時提示「系統未設定發信，請聯繫管理員」，並可選擇「略過驗證（僅限測試）」或僅允許管理員後台開通。

---

## 七、介面調整（註冊區塊）

- **Step 1**  
  - 欄位：電子郵件、密碼、再輸入一次密碼。  
  - 按鈕：「發送驗證碼」（取代目前「建立帳號」）。  
  - 說明：「我們將寄送 6 位數驗證碼至您的信箱，請於 15 分鐘內輸入。」

- **Step 2**（發送成功後）  
  - 顯示：「驗證碼已發送至 xxx@...，請至信箱查收。」  
  - 輸入框：驗證碼（6 位）。  
  - 按鈕：「完成註冊」。  
  - 可選：「重新發送驗證碼」（需遵守發送頻率限制）。

- 錯誤與提示  
  - 驗證碼錯誤、過期：明確提示「驗證碼錯誤或已過期，請重新發送」。  
  - 發送失敗：顯示「無法寄送驗證碼，請檢查信箱是否正確或稍後再試」，並可保留「重新發送」。

---

## 八、實作順序建議

1. **資料庫**  
   - 新增表 `pending_verifications`（email, password_hash, code, expires_at）。  
   - 在 `users` 表新增 `email_verified`（可選，用於未來僅允許已驗證帳號登入）。

2. **發信**  
   - 撰寫 `send_verification_email(to_email, code)`，讀取 Secrets 中 SMTP 設定；未設定則回傳 False，並在註冊流程中依「未設定 SMTP」策略處理。

3. **註冊流程**  
   - Step 1：表單驗證 → 產生 6 位碼 → 寫入 `pending_verifications` → 發信 → 切換到 Step 2（可用 session_state 記錄「已進入 Step 2」與對應 email）。  
   - Step 2：輸入驗證碼 → 檢查 `pending_verifications` → 寫入 `users`（含 `email_verified=1`）→ 刪除該筆 pending → 自動登入。

4. **登入邏輯**  
   - 若實作 `email_verified`：查詢 users 時僅允許 `email_verified = 1` 或 NULL（相容舊用戶）；未驗證帳號可提示「請先完成信箱驗證」。

5. **安全與維運**  
   - 定期刪除過期 `pending_verifications`（例如 cron 或每次發送前清理過期資料）。  
   - 同一 email 發送頻率限制（例如 3 分鐘內不可重發）。

---

## 九、小結

| 項目 | 建議 |
|------|------|
| 驗證方式 | 6 位數驗證碼，發送到用戶信箱 |
| 暫存 | 新表 `pending_verifications` |
| 發信 | smtplib + Secrets（SMTP_*） |
| 未設定 SMTP | 維持目前「僅帳密註冊」並加說明 |
| 舊用戶 | users 表加 `email_verified`，NULL 視為已驗證 |
| 註冊 UI | 兩步：發送驗證碼 → 輸入驗證碼並完成註冊 |

若你同意此方案，可依上述順序在 `app.py` 與 DB 中實作；若有偏好（例如一定要驗證連結、或 SMTP 想用 SendGrid API），可再調整方案細節。
