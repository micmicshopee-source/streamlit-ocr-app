# Bug 詳細報告

**報告日期**: 2026-01-26  
**應用版本**: app.py  
**報告類型**: 詳細 Bug 分析

---

## 🐛 Bug 詳細列表

### Bug #1: SQL 注入風險 (P0 - 嚴重)

**嚴重程度**: P0 - 必須立即修復  
**影響範圍**: 內存模式數據查詢  
**發現位置**: `app.py:759`

#### 問題描述
在內存模式的 SQL 查詢構建中，直接使用字符串拼接而非參數化查詢，存在潛在的 SQL 注入風險。

#### 問題代碼
```python
# 第 759 行
if "WHERE" in query.upper():
    query = query.upper().replace("WHERE", f"WHERE user_email = '{user_email}' AND", 1)
else:
    query = query + f" WHERE user_email = '{user_email}'"
```

#### 風險分析
1. **當前風險**: 雖然是內存模式（不直接操作數據庫），但這種做法不安全
2. **未來風險**: 如果將來改為直接數據庫查詢，會存在嚴重的 SQL 注入風險
3. **代碼一致性**: 與數據庫模式的參數化查詢不一致

#### 復現步驟
1. 註冊一個用戶，郵箱為: `test' OR '1'='1@example.com`
2. 在內存模式下查詢數據
3. 觀察查詢構建過程

#### 修復建議
```python
# 建議修復代碼
# 雖然是內存模式，但應該保持一致的編碼風格
# 可以考慮使用參數化查詢的邏輯，即使是在內存中過濾
if "WHERE" in query.upper():
    # 使用參數化方式構建查詢條件
    where_condition = "user_email = ?"
    # 在內存中過濾時使用安全的字符串比較
else:
    where_condition = "user_email = ?"
```

#### 修復優先級
**高** - 建議立即修復

---

### Bug #2: 刪除功能缺少確認對話框 (P1 - 重要)

**嚴重程度**: P1 - 應盡快修復  
**影響範圍**: 數據刪除功能  
**發現位置**: `app.py:2143`

#### 問題描述
刪除數據時沒有確認對話框，用戶可能誤刪重要數據。

#### 問題代碼
```python
# 第 2143 行
if st.button("🗑️ 刪除選中數據"):
    # 直接刪除，沒有確認
    selected_indices = df[df["選取"]==True].index
    # ... 刪除邏輯
```

#### 影響分析
1. **用戶體驗**: 誤刪數據後無法恢復（除非有備份）
2. **數據安全**: 缺少二次確認機制
3. **操作風險**: 批量刪除時風險更大

#### 復現步驟
1. 選擇多條數據
2. 點擊"刪除選中數據"按鈕
3. 數據立即被刪除，沒有確認提示

#### 修復建議
```python
# 建議修復代碼
if st.button("🗑️ 刪除選中數據"):
    selected_indices = df[df["選取"]==True].index
    if len(selected_indices) > 0:
        # 使用對話框確認
        with st.dialog("確認刪除") as dialog:
            st.warning(f"確定要刪除選中的 {len(selected_indices)} 條數據嗎？此操作不可恢復！")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("確認刪除", type="primary"):
                    # 執行刪除邏輯
                    dialog.close()
            with col2:
                if st.button("取消"):
                    dialog.close()
```

#### 修復優先級
**高** - 建議盡快修復

---

### Bug #3: 刪除功能在篩選後可能失效 (P1 - 重要)

**嚴重程度**: P1 - 應盡快修復  
**影響範圍**: 數據刪除功能  
**發現位置**: `app.py:2162-2172`

#### 問題描述
當數據經過搜索或篩選後，刪除功能可能無法正確獲取記錄 ID，導致無法刪除。

#### 問題代碼
```python
# 第 2162-2172 行
else:
    # 如果沒有df_with_id，從原始查詢結果中獲取ID
    selected_indices = df[df["選取"]==True].index
    if len(selected_indices) > 0:
        # 從df_raw中獲取對應的ID（使用索引匹配）
        if not df_raw.empty and 'id' in df_raw.columns:
            # 需要根據索引找到對應的原始記錄
            # 由於df可能經過篩選，需要重新查詢或使用其他方式
            st.warning("⚠️ 無法確定要刪除的記錄ID，請刷新頁面後重試")
```

#### 影響分析
1. **功能缺陷**: 用戶無法刪除篩選後的數據
2. **用戶體驗**: 需要刷新頁面才能刪除，體驗差
3. **數據一致性**: 可能導致數據不一致

#### 復現步驟
1. 使用搜索功能篩選數據
2. 選擇篩選後的數據
3. 點擊刪除按鈕
4. 看到警告信息，無法刪除

#### 修復建議
```python
# 建議修復代碼
# 在篩選時保留原始索引映射
if not df.empty:
    # 添加原始索引列（在篩選前）
    df['_original_index'] = df.index
    
    # 刪除時使用原始索引
    if 'df_with_id' in locals() and df_with_id is not None:
        selected_indices = df[df["選取"]==True].index
        # 使用原始索引獲取ID
        original_indices = df.loc[selected_indices, '_original_index']
        ids = df_with_id.loc[original_indices, "id"].tolist()
```

#### 修復優先級
**高** - 建議盡快修復

---

### Bug #4: 數據編輯保存時缺少完整錯誤處理 (P1 - 重要)

**嚴重程度**: P1 - 應盡快修復  
**影響範圍**: 數據編輯功能  
**發現位置**: `app.py:2247-2260`

#### 問題描述
數據編輯保存時，如果部分記錄保存失敗，錯誤信息顯示不完整，只顯示前3個錯誤。

#### 問題代碼
```python
# 第 2252-2256 行
if saved_count > 0:
    st.success(f"✅ 已自動保存 {saved_count} 筆數據變更")
    if errors:
        for err in errors[:3]:  # 只顯示前3個錯誤
            st.warning(err)
```

#### 影響分析
1. **信息丟失**: 如果錯誤超過3個，後續錯誤不會顯示
2. **問題排查**: 無法看到完整的錯誤信息，不利於問題排查
3. **用戶體驗**: 用戶可能不知道還有其他錯誤

#### 復現步驟
1. 編輯多條數據（>3條）
2. 故意設置一些無效數據
3. 保存時會看到只顯示前3個錯誤

#### 修復建議
```python
# 建議修復代碼
if saved_count > 0:
    st.success(f"✅ 已自動保存 {saved_count} 筆數據變更")
    if errors:
        if len(errors) > 3:
            with st.expander(f"⚠️ 發現 {len(errors)} 個錯誤（點擊查看詳情）", expanded=False):
                for err in errors:
                    st.error(err)
        else:
            for err in errors:
                st.error(err)
```

#### 修復優先級
**中** - 建議盡快修復

---

### Bug #5: OCR 識別失敗時缺少重試機制 (P1 - 重要)

**嚴重程度**: P1 - 應盡快修復  
**影響範圍**: OCR 識別功能  
**發現位置**: `app.py:1036-1133`

#### 問題描述
OCR 識別失敗時，雖然會嘗試多個 API 端點，但沒有針對網絡錯誤的重試機制。

#### 問題代碼
```python
# 第 1094-1130 行
try:
    resp = session.post(url, json=payload, timeout=25)
    if resp.status_code == 200:
        # ... 處理成功響應
    else:
        last_err = f"HTTP {resp.status_code}: {resp.text[:100]}"
        # 沒有重試機制
except Exception as e: 
    last_err = str(e)
    # 直接繼續下一個配置，沒有重試
    continue
```

#### 影響分析
1. **網絡波動**: 臨時網絡問題會導致識別失敗
2. **用戶體驗**: 需要重新上傳圖片
3. **API 穩定性**: 無法應對臨時的 API 服務問題

#### 復現步驟
1. 在網絡不穩定的環境下上傳圖片
2. 觀察 OCR 識別過程
3. 如果網絡波動，識別會失敗

#### 修復建議
```python
# 建議修復代碼
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# 配置重試策略
retry_strategy = Retry(
    total=3,
    backoff_factor=1,
    status_forcelist=[429, 500, 502, 503, 504],
)
adapter = HTTPAdapter(max_retries=retry_strategy)
session.mount("http://", adapter)
session.mount("https://", adapter)

# 在請求時使用重試
try:
    resp = session.post(url, json=payload, timeout=25)
    # ... 處理響應
except requests.exceptions.RequestException as e:
    # 記錄錯誤，繼續嘗試下一個配置
    last_err = str(e)
    continue
```

#### 修復優先級
**中** - 建議盡快修復

---

### Bug #6: 圖片保存路徑可能衝突 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: 圖片保存功能  
**發現位置**: `app.py:918-937`

#### 問題描述
雖然使用了時間戳和哈希，但在高並發情況下仍可能出現文件名衝突。

#### 問題代碼
```python
# 第 927-930 行
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
file_hash = hashlib.md5(file_name.encode()).hexdigest()[:8]
safe_filename = f"{timestamp}_{file_hash}_{file_name}"
```

#### 影響分析
1. **文件覆蓋**: 如果同一用戶在同一秒內上傳同名文件，可能覆蓋
2. **數據丟失**: 被覆蓋的文件無法恢復
3. **並發問題**: 多用戶同時上傳時可能衝突

#### 復現步驟
1. 在同一秒內上傳兩個同名文件
2. 觀察文件保存結果
3. 可能出現文件覆蓋

#### 修復建議
```python
# 建議修復代碼
import uuid

timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
file_hash = hashlib.md5(file_name.encode()).hexdigest()[:8]
unique_id = str(uuid.uuid4())[:8]
safe_filename = f"{timestamp}_{file_hash}_{unique_id}_{file_name}"
```

#### 修復優先級
**低** - 可稍後修復

---

### Bug #7: 數據庫查詢自動添加 user_email 邏輯可能出錯 (P1 - 重要)

**嚴重程度**: P1 - 應盡快修復  
**影響範圍**: 數據庫查詢功能  
**發現位置**: `app.py:789-798`

#### 問題描述
自動添加 user_email 條件的邏輯過於複雜，可能在某些複雜 SQL 查詢中出錯。

#### 問題代碼
```python
# 第 789-798 行
if "FROM invoices" in query.upper() and "user_email" not in query.upper() and "WHERE" not in query.upper():
    modified_query = query + " WHERE user_email = ?"
    modified_params = [user_email] + list(params)
elif "FROM invoices" in query.upper() and "user_email" not in query.upper() and "WHERE" in query.upper():
    where_pos = query.upper().find("WHERE")
    modified_query = query[:where_pos+5] + " user_email = ? AND " + query[where_pos+5:]
    modified_params = [user_email] + list(params)
```

#### 影響分析
1. **子查詢問題**: 如果查詢包含子查詢，可能錯誤添加條件
2. **JOIN 問題**: 如果查詢使用 JOIN，邏輯可能不正確
3. **複雜查詢**: 對於複雜的 SQL 查詢，自動添加可能導致語法錯誤

#### 復現步驟
1. 構建一個包含子查詢的 SQL
2. 觀察自動添加 user_email 的結果
3. 可能出現 SQL 語法錯誤

#### 修復建議
```python
# 建議修復代碼
# 簡化邏輯，或要求所有查詢明確指定 user_email
# 或者使用更智能的 SQL 解析

# 方案1: 要求明確指定
# 在文檔中要求所有查詢必須包含 user_email 條件

# 方案2: 使用 SQL 解析庫
# 使用 sqlparse 等庫來正確解析和修改 SQL
```

#### 修復優先級
**中** - 建議盡快修復

---

### Bug #8: 內存模式下數據統計不準確 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: 數據統計功能  
**發現位置**: `app.py:1208`

#### 問題描述
在數據庫模式下，統計查詢雖然會自動過濾 user_email，但邏輯可能不夠精確。

#### 問題代碼
```python
# 第 1208 行
db_count_df = run_query("SELECT count(*) as count FROM invoices", ())
```

#### 影響分析
1. **統計準確性**: 雖然會自動過濾，但對於複雜統計可能不準確
2. **性能問題**: 沒有明確的 user_email 條件，可能影響查詢性能

#### 修復建議
```python
# 建議修復代碼
user_email = st.session_state.get('user_email', 'default_user')
db_count_df = run_query("SELECT count(*) as count FROM invoices WHERE user_email = ?", (user_email,))
```

#### 修復優先級
**低** - 可稍後修復

---

### Bug #9: PDF 導出時缺少錯誤處理 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: PDF 導出功能  
**發現位置**: `app.py:1883-2014`

#### 問題描述
PDF 生成過程中，如果字體加載失敗或其他錯誤，可能導致導出失敗但沒有友好提示。

#### 影響分析
1. **用戶體驗**: 導出失敗時沒有明確提示
2. **錯誤排查**: 無法知道具體失敗原因

#### 修復建議
```python
# 建議修復代碼
try:
    pdf_data = generate_pdf()
    st.download_button("📄 PDF", pdf_data, ...)
except Exception as e:
    st.error(f"PDF 生成失敗: {str(e)}")
    if debug_mode:
        st.exception(e)
```

#### 修復優先級
**低** - 可稍後修復

---

### Bug #10: 日期格式轉換可能失敗 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: 日期篩選功能  
**發現位置**: `app.py:2045-2068`

#### 問題描述
日期格式轉換時，如果格式不匹配，會嘗試字符串匹配，但可能不夠準確。

#### 修復建議
支持多種日期格式，或提供日期格式選擇。

#### 修復優先級
**低** - 可稍後修復

---

### Bug #11: 重複發票檢測邏輯可能誤判 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: 重複檢測功能  
**發現位置**: `app.py:939-960`

#### 問題描述
重複檢測只基於發票號碼和日期，如果發票號碼為 "No" 或 "N/A" 則不檢測。

#### 修復建議
添加圖片哈希比較或其他重複檢測機制。

#### 修復優先級
**低** - 可稍後修復

---

### Bug #12: 對話框關閉後狀態未正確清理 (P2 - 中等)

**嚴重程度**: P2 - 可稍後修復  
**影響範圍**: 上傳對話框  
**發現位置**: `app.py:1372-1375`

#### 問題描述
對話框關閉後，某些狀態可能殘留。

#### 修復建議
在對話框關閉時清理所有相關狀態。

#### 修復優先級
**低** - 可稍後修復

---

## 📊 Bug 統計摘要

### 按嚴重程度分類
- **P0 (嚴重)**: 1 個
- **P1 (重要)**: 5 個
- **P2 (中等)**: 6 個

### 按功能模塊分類
- **數據庫相關**: 3 個
- **數據操作**: 3 個
- **OCR 功能**: 1 個
- **文件處理**: 2 個
- **UI/UX**: 3 個

### 修復優先級建議
1. **立即修復** (P0): Bug #1
2. **盡快修復** (P1): Bug #2, #3, #4, #5, #7
3. **計劃修復** (P2): Bug #6, #8, #9, #10, #11, #12

---

## 📝 修復計劃建議

### 第一階段（緊急修復）
- [ ] Bug #1: SQL 注入風險
- [ ] Bug #2: 刪除確認對話框
- [ ] Bug #3: 刪除功能在篩選後失效

### 第二階段（重要修復）
- [ ] Bug #4: 數據編輯保存錯誤處理
- [ ] Bug #5: OCR 重試機制
- [ ] Bug #7: 數據庫查詢邏輯優化

### 第三階段（改進修復）
- [ ] Bug #6, #8, #9, #10, #11, #12

---

**報告生成時間**: 2026-01-26  
**報告版本**: v1.0
