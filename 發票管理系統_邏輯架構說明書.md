# 發票管理系統 — 系統邏輯架構說明書

**角色**：資深產品經理  
**目的**：在調整 UI 樣式（如套用 Tailwind Invoice 模板）之前，釐清「資料層級」「交互邏輯」「狀態管理」三者，確保邏輯無懈可擊。  
**適用**：發票報帳小秘笈模組。  
**更新日期**：2026-01-30

---

## 一、總覽與原則

| 維度 | 說明 |
|------|------|
| **資料層級** | Batch（組）與 Invoice（單張）的定義、關聯、以及上傳時 Batch ID 的產生規則。 |
| **交互邏輯** | 搜尋關鍵字時，系統何時「按組顯示」、何時「按單張顯示」，以及切換條件。 |
| **狀態管理** | 手動修改表格後，資料庫如何同步、「已修改」狀態如何標記與清除。 |

**設計原則**：  
- 一筆上傳操作（一次 OCR 多張圖 / 一次 CSV 導入）= 一個 Batch。  
- 預設「按組顯示」方便整批檢視；有搜尋關鍵字時「按單張顯示」方便精準核對。  
- 所有寫入/更新皆可追溯（建立時間、修改時間、同步狀態）。

---

## 二、資料層級邏輯

### 2.1 名詞定義

| 名詞 | 定義 |
|------|------|
| **Batch（組）** | 同一次上傳動作所產生的發票集合。例如：一次選擇 5 張照片做 OCR → 1 個 Batch、5 張 Invoice；一次匯入 1 個 CSV（內含 20 筆）→ 1 個 Batch、20 張 Invoice。 |
| **Invoice（單張）** | 單一發票/收據的辨識或匯入結果，對應一筆可編輯、可刪除的資料列。 |

### 2.2 關係定義

- **一對多**：一個 Batch 對應多筆 Invoice；一筆 Invoice 只屬於一個 Batch。  
- **可選**：若系統尚未實作 Batch（或為相容舊資料），Invoice 可允許 `batch_id = NULL`，視為「未分組」或「舊資料」。

### 2.3 上傳時如何產生 Batch ID

| 情境 | 規則 |
|------|------|
| **OCR 上傳** | 使用者在同一次對話中選擇多張圖片並按下「開始辨識」→ **在開始處理前** 先產生一筆 Batch 記錄（見下方資料庫欄位），取得 `batch_id`；該次辨識產生的每一筆 Invoice 皆寫入此 `batch_id`。 |
| **CSV/Excel 導入** | 使用者選擇一個檔案並按下「開始導入」→ **在開始解析前** 先產生一筆 Batch 記錄，取得 `batch_id`；該次導入的每一筆發票列皆寫入此 `batch_id`。 |
| **單張補傳** | 若未來支援「單張補傳至既有 Batch」，則可傳入既有 `batch_id`；否則單張上傳可視為「僅 1 張的 Batch」，仍產生新 Batch。 |

**Batch ID 產生方式建議**：  
- **資料庫**：`batches` 表使用 `id INTEGER PRIMARY KEY AUTOINCREMENT`，由 DB 產生唯一 `batch_id`。  
- **記憶體模式**：可用 `uuid.uuid4().hex` 或 `timestamp + 隨機尾碼`，保證同一 session 內不重複即可。

### 2.4 資料庫欄位變動建議

#### （1）新增表：`batches`

| 欄位 | 類型 | 說明 |
|------|------|------|
| `id` | INTEGER PRIMARY KEY AUTOINCREMENT | Batch 唯一識別。 |
| `user_email` | TEXT NOT NULL | 所屬用戶（與現有多用戶隔離一致）。 |
| `source` | TEXT NOT NULL | 來源：`ocr` / `import`。 |
| `created_at` | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | 建立時間。 |
| `invoice_count` | INTEGER | 該組發票數量（可選，方便列表顯示；亦可由查詢 COUNT 得出）。 |

#### （2）既有表：`invoices` 新增欄位

| 欄位 | 類型 | 說明 |
|------|------|------|
| `batch_id` | INTEGER NULL | 所屬 Batch 的 id；NULL 表示舊資料或未分組。 |
| `modified_at` | TIMESTAMP NULL | 最後一次手動修改時間；NULL 表示從未修改。 |
| `sync_status` | TEXT | 見下方「狀態管理」；建議值：`synced` / `modified` / `pending`（可選）。 |

**相容舊資料**：  
- 既有的 `invoices` 資料不帶 `batch_id`，查詢時視為「未分組」；列表可顯示為「未分組」或依建立時間虛擬分組。  
- 新上傳的資料一律寫入 `batch_id`。

---

## 三、交互邏輯：搜尋時「按組」與「按單張」的切換

### 3.1 顯示模式定義

| 模式 | 說明 | 適用情境 |
|------|------|----------|
| **按組顯示（預設）** | 以 Batch 為單位彙總顯示：例如每個卡片/區塊代表一個 Batch，底下可展開該組內所有 Invoice，或顯示組內張數、總金額、日期區間等。 | 無搜尋關鍵字時，使用者通常想「看這批上傳的整組結果」。 |
| **按單張顯示** | 與現有行為一致：表格每一列 = 一筆 Invoice，可篩選、可編輯、可刪除。 | 有搜尋關鍵字時，使用者想「精準找到符合條件的單張發票」。 |

### 3.2 切換規則（建議）

| 條件 | 顯示模式 |
|------|----------|
| 搜尋框為**空** | **按組顯示**：列出所有 Batch（可依建立時間倒序），每個 Batch 可展開看該組內發票列表或彙總資訊。 |
| 搜尋框**有輸入**（含至少 1 個字元） | **按單張顯示**：僅顯示符合關鍵字的 Invoice 列（與現有搜尋邏輯一致：發票號碼、賣方名稱、檔名等欄位包含關鍵字即符合）。 |

**實作要點**：  
- 搜尋關鍵字由前端輸入框即時取得；後端依「有無關鍵字」決定查詢與組裝資料的方式。  
- 「按組顯示」時，查詢對象為 `batches` + 各 Batch 下的 Invoice 彙總（或明細）；「按單張顯示」時，查詢對象為 `invoices`（並套用關鍵字、日期、狀態等篩選）。

### 3.3 流程簡圖

```
使用者進入發票列表
       │
       ▼
 搜尋框有內容？
   │         │
  否        是
   │         │
   ▼         ▼
按組顯示   按單張顯示
(Batch 列表) (Invoice 表格，套用關鍵字篩選)
   │         │
   ▼         ▼
可展開組   可編輯/刪除/導出
看單張
```

---

## 四、狀態管理邏輯：手動修改與資料庫同步

### 4.1 「已修改」的定義

- 使用者透過**資料表格**（如 `st.data_editor`）**編輯**了某一筆 Invoice 的欄位（例如日期、發票號碼、賣方、金額、會計科目、備註等），並觸發儲存（例如失焦、按「儲存」、或定時比對後寫入）。  
- 系統將該筆記錄標記為「已修改」，並在**寫入資料庫（或記憶體）時**更新對應欄位。

### 4.2 資料庫如何同步

| 步驟 | 說明 |
|------|------|
| 1. 偵測變更 | 比對「目前表格資料」與「上次載入的原始資料」（或與 DB 讀出資料），以 `id` 對應列，逐欄比較；有任一欄位不同即視為該筆已修改。 |
| 2. 寫回儲存體 | 對「已修改」的每一筆執行 UPDATE：更新業務欄位（date, invoice_number, seller_name, …）以及 `modified_at = CURRENT_TIMESTAMP`；若採用 `sync_status`，則可設為 `synced`（表示已寫入 DB）。 |
| 3. 記憶體模式 | 若為 `local_invoices`，則直接更新 list 中對應元素，並可選擇性寫入 `modified_at`（若記憶體結構支援）。 |
| 4. 衝突與重試 | 若 UPDATE 失敗（例如 DB 鎖定、連線中斷），可保留「待同步」狀態（如 `sync_status = 'pending'`），下次載入時重試或提示使用者。 |

### 4.3 「已修改」狀態如何標記

**建議欄位**（已在 2.4 節列出）：  

- **`modified_at`**（TIMESTAMP NULL）  
  - NULL：從未經由表格編輯過。  
  - 有值：最後一次手動修改的時間。  

**可選欄位**：  

- **`sync_status`**（TEXT）  
  - `synced`：已成功寫入 DB。  
  - `modified`：前端/記憶體已改，尚未寫回 DB（多用於離線或延遲寫入情境）。  
  - `pending`：寫入失敗待重試。  

**前端顯示**：  
- 在「按單張顯示」的表格中，可加一欄「修改時間」或圖示（例如鉛筆 icon），僅在 `modified_at` 非空時顯示，讓使用者一眼辨識哪些列曾被手動改過。

### 4.4 流程簡圖

```
使用者在表格中編輯某一列
       │
       ▼
 失焦 / 按儲存 / 定時比對
       │
       ▼
 比對該列與原始資料 → 有變更？
       │         │
      否        是
       │         │
       ▼         ▼
   不寫入     UPDATE invoices SET
              field1=?, ..., modified_at=CURRENT_TIMESTAMP
              WHERE id=? AND user_email=?
                    │
                    ▼
              成功 → modified_at 有值；可選 sync_status='synced'
              失敗 → 可選 sync_status='pending'，稍後重試
```

---

## 五、核心 Function 運作流程

### 5.1 上傳產生 Batch + Invoices（OCR）

```
1. 使用者選擇多張圖片，按下「開始辨識」
2. 若使用 DB：
   - INSERT INTO batches (user_email, source, created_at) VALUES (?, 'ocr', datetime('now'))
   - 取得 batch_id = cursor.lastrowid
3. 若使用記憶體：
   - 產生 batch_id（如 uuid 或 timestamp 字串）
   - 將 batch 資訊存入 session_state（如 local_batches 或每筆 invoice 帶 batch_id）
4. 迴圈：每張圖片
   - 呼叫 process_ocr(...)
   - 組裝 invoice 記錄，寫入 batch_id
   - INSERT INTO invoices (..., batch_id) 或 append 到 local_invoices（含 batch_id）
5. 可選：UPDATE batches SET invoice_count = ? WHERE id = ?
```

### 5.2 上傳產生 Batch + Invoices（CSV/Excel 導入）

```
1. 使用者選擇檔案，按下「開始導入」
2. 同 5.1：先產生一筆 Batch（source = 'import'），取得 batch_id
3. 解析 CSV/Excel，逐列：
   - 組裝 invoice 記錄，寫入 batch_id
   - INSERT INTO invoices (..., batch_id) 或 append 到 local_invoices
4. 可選：更新 batches.invoice_count
```

### 5.3 列表查詢：依「有無搜尋關鍵字」分支

```
1. 取得搜尋關鍵字 search_term = trim(搜尋框內容)
2. if search_term 為空：
   - 查詢 batches（WHERE user_email = ? ORDER BY created_at DESC）
   - 對每個 batch 查詢其 invoices（WHERE batch_id = ?）做彙總或明細
   - 回傳「按組」資料結構（例如 list of { batch_id, created_at, invoices[], summary }）
   - 前端：按組顯示（卡片/可展開）
3. else：
   - 查詢 invoices（WHERE user_email = ? AND (發票號碼/賣方/檔名 等 LIKE ?) 再套用日期、狀態等篩選）
   - 回傳扁平 Invoice 列表
   - 前端：按單張顯示（現有表格）
```

### 5.4 手動修改表格後寫回（save_edited_data）

```
1. 輸入：ed_df（使用者編輯後的 DataFrame）、original_df（上次載入的原始資料）、user_email
2. 對 ed_df 每一列（以 id 對應）：
   - 與 original_df 同 id 的列比對；若無變更則 skip
   - 若有變更：組裝 UPDATE 欄位（含 modified_at = CURRENT_TIMESTAMP）
3. 若 use_memory_mode：
   - 更新 st.session_state.local_invoices 中對應 id 的 dict，並寫入 modified_at
4. 否則：
   - 執行 UPDATE invoices SET ... , modified_at = CURRENT_TIMESTAMP WHERE id = ? AND user_email = ?
5. 回傳 (saved_count, errors)
```

---

## 六、資料庫欄位變動彙總

| 項目 | 變動 |
|------|------|
| **新增表** | `batches`：id, user_email, source, created_at, invoice_count（可選） |
| **invoices 新增欄位** | `batch_id` (INTEGER NULL), `modified_at` (TIMESTAMP NULL), `sync_status` (TEXT，可選) |
| **索引建議** | `batches(user_email)`, `batches(created_at)`；`invoices(batch_id)` |

**遷移注意**：  
- 舊資料 `batch_id` 為 NULL，不影響既有查詢；新上傳一律帶 `batch_id`。  
- `modified_at` 舊資料為 NULL，表示從未在表格中修改過。

---

## 七、與 UI 的銜接

- **按組顯示**：UI 設計師可依「Batch 卡片 + 可展開明細」的結構套用 Tailwind 模板（例如一卡一組，標題為上傳時間與張數，內容為該組發票列表或彙總）。  
- **按單張顯示**：維持現有表格行為，僅需在「狀態/備註」旁或獨立欄位顯示「修改時間」或圖示（當 `modified_at` 有值時）。  
- **搜尋框**：保留現有輸入框，邏輯改為「有內容 → 按單張顯示；空 → 按組顯示」，前端依後端回傳的資料結構切換元件即可。

---

## 八、確認清單（邏輯通順後再交給 UI）

- [ ] Batch 與 Invoice 關係、Batch ID 產生時機已確定。  
- [ ] 搜尋為空 → 按組顯示；搜尋有字 → 按單張顯示，規則已確定。  
- [ ] 手動修改後寫回 DB、`modified_at` 更新與「已修改」標記方式已確定。  
- [ ] 資料庫欄位變動（batches 表、invoices 新增欄位）已與開發共識。  
- [ ] 核心 Function（上傳、列表查詢、save_edited_data）流程已與現有程式碼對齊，可實作或重構。

完成上述確認後，即可由 UI 設計師套用 Tailwind 的 Invoice 模板，並依「按組／按單張」兩種情境設計版面與元件。
